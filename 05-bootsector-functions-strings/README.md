*一些你可能需要提前查询的概念：控制结构、函数调用、字符串*

**目标：学会使用汇编编写基本的循环、函数**

我们离目标已经很近了。

在第7课中我们将开始从磁盘读取数据，这是加载内核之前的最后一步，但是首先我们要学习一下编写一些带有控制结构、函数调用和完整字符串使用的代码。在跳到磁盘和内核之前，我们需要熟悉这些概念。

Strings
-------

像定义字节一样定义字符串，但是用一个空字节结尾（类似于C语言的字符串结尾），这样方便我们判定一个字符串是否结束了。

```nasm
mystring:
    db 'Hello, World', 0
```

请注意，用`''`括起来的文本被汇编器转换为ASCII码，而那个单独的零将作为字节`0x00`追加在末尾。  

控制流程
------------------

我们已经在无限循环中使用了一个:`jmp $`。  

汇编将由由*前面的*指令结果定义跳转的目的地。举个例子：  

```nasm
cmp ax, 4      ; if ax = 4
je ax_is_four  ; do something (by jumping to that label)
jmp else       ; else, do another thing
jmp endif      ; finally, resume the normal flow

ax_is_four:
    .....
    jmp endif

else:
    .....
    jmp endif  ; not actually necessary but printed here for completeness

endif:
```

汇编是一段“字节流”，无论流到哪里都会继续往下流，而label只不过是一个助记符而已，实际上的实现方式就是在汇编的时候把label替换成地址。

有许多`jmp`条件，比如JE（相等）、JNE（不等）、JG（大于）、JGE（大于或等于）、JL（小于）、JLE（小于或等于）。


调用函数
-----------------

如你所想，调用一个函数只是跳转到一个标签而已。

棘手的部分是参数，传入参数有两种方式:  

1. 程序员知道变量存放在哪一个具体的寄存器中。
2. 在编写函数调用代码的时候麻烦一点但是不会导致意外。

第一种方式是十分简单的，让我们约定使用`al`寄存器(`ax`寄存器的低地址部分)来传参数，这样的话代码是下面这样的：
```nasm
mov al, 'X'
jmp print
endprint:

...

print:
    mov ah, 0x0e  ; tty code
    int 0x10      ; I assume that 'al' already has the character
    jmp endprint  ; this label is also pre-agreed
```

你可以看到，这种方法将很快发展成一坨翔。当前的`print`函数将只能返回到`endprint`位置，如果其他函数想调用print函数就很难办了，这与软件工程里面的代码重用思想是背道而驰的。  

正确的函数调用应该在此基础之上做出两处改进：

- 应该把返回地址存起来，因为每个返回地址（返回到调用此函数的位置）可能都不一样。
- 我们将保存当前寄存器，以允许在函数修改它们而不产生任何副作用

我们不需要自己存储返回地址，CPU会帮助我们。我们也不需要使用`jmp`来调用函数了，取而代之的是`call`和`ret`。

CALL 指令调用一个过程，指挥处理器将当前的IP寄存器或CS和IP寄存器压入栈中，然后从新的内存地址开始执行。CS:IP两个寄存器指示了CPU当前将要读取的指令的地址，其中CS为代码段寄存器，而IP为指令指针寄存器 。

过程使用RET（从过程返回）指令将处理器转回到该过程被调用的程序点上，其实实现的功能就是把CS和IP寄存器弹出栈。

为了保存寄存器数据，还有一个使用堆栈的特殊命令:`pusha`和它的兄弟`popa`，`pusha`自动将所有寄存器推入堆栈，`popa`会恢复它们。 


包含外部文件
------------------------

如果你是一个程序员，那你应该知道这是一个好习惯。 

语法是这样的：
```nasm
%include "file.asm"
```


以十六进制打印
-------------------

在下一课中，我们将开始从磁盘读取数据，因此我们需要某种方法来确保读取的数据是正确的。`boot_sect_print_hex.asm`文件是`boot_sect_print.asm`的功能上的拓展。我们将使用`boot_sect_print_hex.asm`里面的程序来以十六进制的形式打印内容。

ROR是循环右移指令，把目的操作数整体右移由源操作数指定的位数，被移出的位依次回填到左边空出的位，同时移进标志位。
举个例子：3转换成二进制数为：00000011，循环右移一位之后变成：10000001；再循环右移一位之后变成：11000000。


代码解释
-----

让我们来看看代码。`boot_sect_print.asm`是一个子程序，它将在主文件中被`%include`，文件里使用一个循环将字节打印到屏幕上，它还包含一个用于打印换行符的函数。我们熟悉的换行符`\n`实际上是两个字节，换行符`0x0A`和回车符`0x0D`。你也可以试着去掉回车字符，看看效果如何。

如上所述，你可以利用`boot_sect_print_hex.asm`文件里的函数来打印字节的十六进制表示。

主文件`boot_sect_main.asm`作用是加载两个字符串，然后调用`print`和`print_hex`并挂起。 如果您理解了前面的部分，那么它是非常简单的。